{"version":3,"sources":["../lib/Metas.js"],"names":[],"mappings":"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","file":"Metas.js","sourcesContent":["\nconst logger = Loggers.create(__filename, 'info');\n\nexport function isSpecType(meta, type) {\n   logger.debug('isSpecType', meta.spec, type);\n   return meta.spec.includes(type);\n}\n\nexport function pickEnv(meta, env) {\n   const result = {};\n   Object.keys(meta).filter(key => env.hasOwnProperty(key))\n   .forEach(key => result[key] = env[key]);\n   return result;\n}\n\nexport function getErrorKeys(meta, props) {\n   return Object.keys(meta).filter(key => !isValid(meta[key], key, props[key]));\n}\n\nfunction isValid(meta, key, value) {\n   logger.debug('isValid', key, value, meta);\n   if (lodash.isString(meta)) {\n      return lodash.isString(value);\n   } else if (value === undefined) {\n      return meta.optional;\n   } else if (meta.type === 'url') {\n      return typeof value === 'string' && value.match(/^http/);\n   } else if (meta.type === 'file') {\n      return typeof value === 'string' && Files.existsFile(value);\n   } else if (meta.type === 'string') {\n      return typeof value === 'string';\n   } else if (meta.type === 'duration') {\n      return parseInt(value) === value;\n   } else if (meta.type === 'integer') {\n      return parseInt(value) === value;\n   } else if (meta.type === 'boolean' || lodash.isBoolean(meta.defaultValue)) {\n      return lodash.isBoolean(value);\n   } else if (meta.type === 'object') {\n      return Object.keys(value).length;\n   } else if (lodash.isString(meta.defaultValue) && lodash.isString(value)) {\n      if (meta.regex) {\n         logger.debug('isValid', meta, value);\n         return new RegExp('^' + meta.regex + '$').test(value);\n      } else {\n         return true;\n      }\n   } else if (meta.defaultValue > 0 && value > 0) {\n      if (meta.regex) {\n         return new RegExp('^' + meta.regex + '$').test('' + value);\n      } else {\n         return true;\n      }\n      return true;\n   } else if (lodash.isArray(meta.defaultValue) && lodash.isArray(value)) {\n      return true;\n   } else {\n      return false;\n   }\n}\n\nexport function getDefault(meta) {\n   const result = {};\n   Object.keys(meta)\n   .filter(key => Values.isDefined(translateMeta(meta[key]).defaultValue))\n   .forEach(key => result[key] = translateMeta(meta[key]).defaultValue);\n   return result;\n}\n\nfunction translateMeta(meta) {\n   if (lodash.isString(meta)) {\n      return {\n         type: 'string',\n         defaultValue: meta\n      };\n   } else {\n      return meta;\n   }\n}\n\nexport function getEnv(meta, componentName, env) {\n   const result = {};\n   Object.keys(meta).filter(key => {\n      const envKey = [componentName, key].join('_');\n      return env.hasOwnProperty(envKey);\n   }).forEach(key => {\n      const envKey = [componentName, key].join('_');\n      result[key] = env[envKey];\n   });\n   logger.info('getEnv', componentName, Object.keys(result));\n   return result;\n}\n\n// TODO integration the following\n\n/*\nvar that = {\n   minTimestamp: 1459109145,\n   minInterval: 1,\n   maxInterval: 3600,\n   defaultProps: {},\n   validateProps: function(p) {\n      Asserts.assertIntegerMax(p.serviceRenew, 'serviceRenew', p.serviceExpire - 5);\n   },\n   start: function(props) {\n      Object.keys(props).forEach(function(key) {\n         props[key].key = key;\n         var defaultValue = props[key].defaultValue;\n         if (defaultValue) {\n            that.defaultProps[key] = defaultValue;\n         }\n      });\n      console.log('defaultProps', that.defaultProps);\n      that.validateProps(that.defaultProps);\n      that.props = props;\n   },\n   validate(value, name) {\n      assert.equal(typeof name, 'string', 'name');\n      var meta = that.props[name];\n      if (meta) {\n         that.validateMeta(meta, value, name);\n      }\n      return value;\n   },\n   validateMeta(meta, value, name) {\n      if (value === undefined) {\n         if (!meta.optional) {\n            throw new Error(`missing ${name}`);\n         }\n      }\n      if (meta.min) {\n         if (value >= meta.min) {\n         } else {\n            throw new Error(`${name} (${value}) min ${meta.min}`);\n         }\n      }\n      if (meta.max) {\n         if (value > meta.max) {\n            throw new Error(`${name} (${value}) max ${meta.max}`);\n         }\n      }\n      return value;\n   },\n   addTimestampInterval(timestamp, interval, name) {\n      if (!interval || interval < that.minInterval || interval > that.maxInterval) {\n         throw new Error(`${name} (${interval}) interval`);\n      }\n      return that.parseTimestamp(timestamp, name) + that.parseInt(interval);\n   },\n   validateTimestamp(value, name) {\n      var timestamp = that.parseTimestamp(value, name);\n      if (!timestamp) {\n         throw new Error(`${name} timestamp`);\n      }\n      return timestamp;\n   },\n   validateMinExclusive(value, min, name) {\n      if (value > min) {\n         return value;\n      } else {\n         throw new Error(`${name} (${value}) min ${min}`);\n      }\n   },\n   validateRangeInclusive(value, range, name) {\n      if (value >= range[0] && value <= range[1]) {\n         return value;\n      } else {\n         throw new Error(`${name} (${value}) range ${range}`);\n      }\n   },\n   parseTimestamp(value, name) {\n      var timestamp = that.parseInt(value, name);\n      if (timestamp > 0 && timestamp < that.minTimestamp) {\n         throw new Error(`${name} (${value}) timestamp`);\n      }\n      return timestamp;\n   },\n   parseInt(value, name) {\n      if (value === 0) {\n         return 0;\n      } else if (!value) {\n         return undefined;\n      }\n      var integerValue = parseInt(value);\n      if (typeof value === 'string') {\n      } else if (value !== integerValue) {\n         throw new Error(`${name} (${value}) parseInt type ${typeof value}`);\n      }\n      if (integerValue === NaN) {\n         throw new Error(`${name} (${value}) parseInt NaN`);\n      }\n      return integerValue;\n   },\n   validateInteger(value, name) {\n      return that.validate(value, name);\n   },\n   validateIntegerMin(value, min, name) {\n      that.validate(value, name);\n      if (value >= min) {\n      } else {\n         throw new Error(`${name} (${value}) min ${min}`);\n      }\n      return value;\n   },\n   validateIntegerMin(value, min, name) {\n      that.validate(value, name);\n      if (value >= min) {\n      } else {\n         throw new Error(`${name} (${value}) min ${min}`);\n      }\n      return value;\n   }\n\n};\n*/\n"]}