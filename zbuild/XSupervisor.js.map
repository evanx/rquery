{"version":3,"sources":["../lib/XSupervisor.js"],"names":[],"mappings":"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","file":"XSupervisor.js","sourcesContent":["\nexport default class Supervisor {\n\n   constructor() {\n   }\n\n   async init() {\n      logger.info('config.components', Object.keys(config.components));\n      for (const componentName in config.components) {\n         const componentConfig = config.components[componentName];\n         if (componentConfig) {\n            const componentModule = config.availableComponents[componentName];\n            assert(componentModule, 'componentModule: ' + componentName);\n            await this.initComponent(componentName, componentModule, componentConfig);\n         } else {\n            logger.warn('config.component', componentName);\n         }\n      }\n      await this.startComponents();\n      await this.scheduleComponents();\n      logger.info('components', Object.keys(components));\n      logger.info('inited');\n   }\n\n   async initComponent(componentName, componentModule, componentConfig) { // TODO support external modules\n      assert(typeof componentName === 'string', 'component name');\n      logger.info('initComponent', componentName, componentModule, componentConfig);\n      const meta = CsonFiles.readFileSync(componentModule + '.cson'); // TODO support external modules\n      componentConfig = Object.assign(Metas.getDefault(meta.config), componentConfig);\n      componentConfig = Object.assign(componentConfig, Metas.getEnv(meta.config, componentName, process.env));\n      logger.debug('config', componentName, meta.config, componentConfig);\n      const errorKeys = Metas.getErrorKeys(meta.config, componentConfig);\n      if (errorKeys.length) {\n         throw new ValidationError('config: ' + errorKeys.join(' '));\n      }\n      const componentState = Object.assign({\n         config: componentConfig,\n         logger: Loggers.create(componentName, componentConfig.loggerLevel || config.loggerLevel),\n         supervisor: this,\n         components: components\n      }, meta.state);\n      componentModule = await ClassPreprocessor.buildSync(componentModule + '.js', Object.keys(componentState));\n      const componentClass = require('./' + componentModule).default; // TODO support external modules\n      const component = new componentClass();\n      logger.info('initComponents state', componentName, Object.keys(componentState));\n      Object.assign(component, {name: componentName}, componentState);\n      if (component.init) {\n         assert(lodash.isFunction(component.init), 'init function: ' + componentName);\n         await component.init();\n      }\n      initedComponents.push(component);\n      components[componentName] = component;\n      logger.info('initComponents components', componentName, Object.keys(components));\n   }\n\n   async startComponents() {\n      logger.info('startComponents', initedComponents.length);\n      for (const component of [... initedComponents]) {\n         if (component.start) {\n            assert(lodash.isFunction(component.start), 'start function: ' + component.name);\n            logger.debug('start', component.name);\n            await component.start();\n         }\n      }\n   }\n\n   async scheduleComponents() {\n      logger.debug('scheduleComponents length', Object.keys(components));\n      for (const component of [... initedComponents]) {\n         logger.debug('scheduleComponents component', component.name, Object.keys(component.config));\n         if (component.config.scheduledTimeout) {\n            this.scheduleComponentTimeout(component);\n         }\n         if (component.config.scheduledInterval) {\n            this.scheduleComponentInterval(component);\n         }\n      }\n   }\n\n   scheduleComponentTimeout(component) {\n      assert(component.config.scheduledTimeout > 0, 'component.config.scheduledTimeout');\n      assert(lodash.isFunction(component.scheduledTimeout), 'scheduledTimeout function: ' + component.name);\n      this.scheduledTimeouts[component.name] = setTimeout(async () => {\n         try {\n            await component.scheduledTimeout();\n         } catch (err) {\n            if (component.config.scheduledTimeoutWarn) {\n               logger.warn(err, component.name, component.config);\n            } else {\n               this.error(err, component);\n            }\n         }\n      }, component.config.scheduledTimeout);\n   }\n\n   scheduleComponentInterval(component) {\n      assert(component.config.scheduledInterval > 0, 'component.config.scheduledInterval');\n      assert(lodash.isFunction(component.scheduledInterval), 'scheduledInterval function: ' + component.name);\n      this.scheduledIntervals[component.name] = setInterval(async () => {\n         try {\n            await component.scheduledInterval();\n         } catch (err) {\n            if (component.config.scheduledIntervalWarn) {\n               logger.warn(err, component.name, component.config);\n            } else {\n               this.error(err, component);\n            }\n         }\n      }, component.config.scheduledInterval);\n   }\n\n   async start() {\n      logger.info('start components', Object.keys(components));\n      for (const component of components) {\n         await component.start();\n      }\n      logger.info('started');\n   }\n\n   async error(err, component) {\n      if (!ended) {\n         logger.error(err, component.name);\n         if (err.stack) {\n            logger.error(err.stack);\n         }\n         if (components.metrics) {\n            if (components.metrics !== component) {\n               await components.metrics.count('error', component.name);\n            }\n         }\n         this.end();\n      } else {\n         logger.warn(component.name, err);\n      }\n   }\n\n   async endComponents() {\n      if (initedComponents.length) {\n         initedComponents.reverse();\n         for (const component of initedComponents) {\n            try {\n               await component.end();\n               logger.info('end component', component.name);\n            } catch (err) {\n               logger.error('end component', component.name, err.stack);\n            }\n         }\n      }\n   }\n\n   async end() {\n      await this.endComponents();\n      if (this.redisClient) {\n         await this.redisClient.quitAsync();\n      }\n      process.exit(0);\n   }\n}\n"]}